
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>How It Works &#8212; Breathe &#39;latest&#39; 文档</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="_static/breathe.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/translations.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="Credits" href="credits.html" />
    <link rel="prev" title="Contributing to Breathe" href="contributing.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Breathe &#39;latest&#39; 文档</span></a></h1>
        <h2 class="heading"><span>How It Works</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="contributing.html">Contributing to Breathe</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">目录</a>
        &#160;&#160;::&#160;&#160;
        <a href="credits.html">Credits</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="how-it-works">
<span id="codeguide"></span><h1>How It Works<a class="headerlink" href="#how-it-works" title="永久链接至标题">¶</a></h1>
<p>There are three main sections to Breathe: parser, finders and renderers.
Briefly:</p>
<blockquote>
<div><dl class="simple">
<dt><strong>parser</strong></dt><dd><p>Responsible for reading the doxygen xml output and creating objects
representing the data. Found in <code class="docutils literal notranslate"><span class="pre">breathe.parser</span></code>.</p>
</dd>
<dt><strong>finders</strong></dt><dd><p>Responsible for finding reference objects within the output from the
parser. Found in <code class="docutils literal notranslate"><span class="pre">breathe.finder</span></code>.</p>
</dd>
<dt><strong>renderers</strong></dt><dd><p>Responsible for producing reStructuredText nodes to represent the objects
that the finders have found. The renderers generally descend through the
object hierarchies rendering the objects, their children, their children’s
children and so on. Found in <code class="docutils literal notranslate"><span class="pre">breathe.renderer</span></code>.</p>
</dd>
</dl>
</div></blockquote>
<section id="parser">
<h2>Parser<a class="headerlink" href="#parser" title="永久链接至标题">¶</a></h2>
<p>The parsers job is to parse the doxygen xml output and create a hierarchy of
Python objects to represent the xml data.</p>
<section id="doxygen-xml-output">
<h3>Doxygen XML Output<a class="headerlink" href="#doxygen-xml-output" title="永久链接至标题">¶</a></h3>
<p>The xml output from doxygen comes in multiple files. There is always an
<code class="docutils literal notranslate"><span class="pre">index.xml</span></code> file which is a central reference point and contains a list of all
the other files that have been generated by doxygen and an indication of what
they contain.</p>
<p>For example, in <code class="docutils literal notranslate"><span class="pre">examples/doxygen/func/xml</span></code> directory, the <code class="docutils literal notranslate"><span class="pre">index.xml</span></code> file
contains:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39; standalone=&#39;no&#39;?&gt;
&lt;doxygenindex xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;index.xsd&quot; version=&quot;1.7.2&quot;&gt;
  &lt;compound refid=&quot;class_test&quot; kind=&quot;class&quot;&gt;&lt;name&gt;Test&lt;/name&gt;
    &lt;member refid=&quot;class_test_1a45b6a232a4499f8ce37062eab5451570&quot; kind=&quot;function&quot;&gt;&lt;name&gt;member&lt;/name&gt;&lt;/member&gt;
  &lt;/compound&gt;
  &lt;compound refid=&quot;func_8h&quot; kind=&quot;file&quot;&gt;&lt;name&gt;func.h&lt;/name&gt;
  &lt;/compound&gt;
&lt;/doxygenindex&gt;
</pre></div>
</div>
<p>This suggests there is additional information about a class called <strong>Test</strong>
which has a function called <strong>member</strong>. Additionally there is some more
information about a file called <strong>func.h</strong>.</p>
<p>Now, the <code class="docutils literal notranslate"><span class="pre">refid</span></code> attribute on the <code class="docutils literal notranslate"><span class="pre">compound</span></code> xml nodes gives an indication
of where the additional information can be found. So for the <strong>Test</strong> class, we
should look in <code class="docutils literal notranslate"><span class="pre">class_test.xml</span></code>, which we get by simply appending <code class="docutils literal notranslate"><span class="pre">.xml</span></code> to
the <code class="docutils literal notranslate"><span class="pre">refid</span></code> value, and for the <strong>func.h</strong> file we should look in
<code class="docutils literal notranslate"><span class="pre">func_8h.xml</span></code>.</p>
<p>So the <code class="docutils literal notranslate"><span class="pre">index.xml</span></code> file is unique in its role and has its own structure which
is defined in the <code class="docutils literal notranslate"><span class="pre">index.xsd</span></code> file which you will also find in the same
directory. All the other files, the ones referenced by the <code class="docutils literal notranslate"><span class="pre">index.xml</span></code> file, follow
another structure. This is described in <code class="docutils literal notranslate"><span class="pre">compound.xsd</span></code> file so we call these
other files <strong>compound</strong> files. These are generally longer than the
<code class="docutils literal notranslate"><span class="pre">index.xml</span></code> file and contain all the specific information you might expect
from doxygen, including any documentation you added to your code as doxygen
markup.</p>
<p>Have a look at <code class="docutils literal notranslate"><span class="pre">examples/doxygen/func/xml/class_test.xml</span></code> for a fairly short
example.</p>
</section>
<section id="doing-the-parsing">
<h3>Doing the Parsing<a class="headerlink" href="#doing-the-parsing" title="永久链接至标题">¶</a></h3>
<p>To get things up and running quickly, I have used the <a class="reference external" href="http://www.rexx.com/~dkuhlman/generateDS.html">generateDS</a> project to help create
classes to parse the doxygen xml output. The script automatically creates the
<code class="docutils literal notranslate"><span class="pre">compound.py</span></code>, <code class="docutils literal notranslate"><span class="pre">compoundsuper.py</span></code>, <code class="docutils literal notranslate"><span class="pre">index.py</span></code> and <code class="docutils literal notranslate"><span class="pre">indexsuper.py</span></code> files
that you can see inside <code class="docutils literal notranslate"><span class="pre">breathe/parser/doxygen</span></code>.</p>
<p>So what is the difference between <code class="docutils literal notranslate"><span class="pre">index.py</span></code> and <code class="docutils literal notranslate"><span class="pre">indexsuper.py</span></code>, and
<code class="docutils literal notranslate"><span class="pre">compound.py</span></code> and <code class="docutils literal notranslate"><span class="pre">compoundsuper.py</span></code>? These files allow us to separate the
bulk of the automatically generated code from the code changes we might want to
make. There are a large number of classes in the <code class="docutils literal notranslate"><span class="pre">...super.py</span></code> files and each
one has a basic derived class in the corresponding non-super files.</p>
<p>It is designed so that all the hard work done by the generated code is
done in the <code class="docutils literal notranslate"><span class="pre">...super.py</span></code> files and if we need to make changes we can do them
in the derived classes in the non-super files and if we ever need to regenerate
the code, we only regenerate the <code class="docutils literal notranslate"><span class="pre">...super.py</span></code> files and so we don’t lose our
changes in the process.</p>
<p>The end result is that for the parsing, we have written relatively little code,
but have a large amount automatically generated for us. This has only been done
once and it seems relatively unlikely that we’ll do it again. The entry points to
the parsing code is the <code class="docutils literal notranslate"><span class="pre">parse</span></code> functions at the bottom of the
<code class="docutils literal notranslate"><span class="pre">breathe.parser.doxygen.compound</span></code> and <code class="docutils literal notranslate"><span class="pre">breathe.parser.doxygen.index</span></code>.</p>
<p>I have never really examined the details of the parsing but you can see that
there is a class for each node type you are likely to find in the xml files. I
say “node type” instead of just “node” because different nodes can share the
same type and there is one class per type. For example, there are
<strong>detaileddescription</strong> nodes and <strong>briefdescription</strong> nodes which are both of
type <strong>descriptionType</strong>. If we look in <code class="docutils literal notranslate"><span class="pre">breathe.parser.doxygen.compoundsuper</span></code>
we see a <strong>descriptionType</strong> class and in
<code class="docutils literal notranslate"><span class="pre">breathe.parser.doxygen.compound</span></code> we see a <strong>descriptionTypeSub</strong> class which
is derived from <strong>descriptionType</strong>.</p>
</section>
<section id="our-changes">
<h3>Our Changes<a class="headerlink" href="#our-changes" title="永久链接至标题">¶</a></h3>
<p>You’ll notice there are some classes in the non-super files that have some
additional code in them. This tends to be adjusting the <code class="docutils literal notranslate"><span class="pre">buildChildren</span></code> member
function in the derived class to extend or override the one in the
automatically generated base class.</p>
<p>We have to do this sometimes as it seems the original code we generated with
<code class="docutils literal notranslate"><span class="pre">generateDS</span></code> fails to construct the children of some classes. The
<code class="docutils literal notranslate"><span class="pre">generateDS</span></code> scripts uses the descriptions in the <code class="docutils literal notranslate"><span class="pre">.xsd</span></code> files to determine
what classes to generate and what nodes can be the children of other nodes. It
is possible that the doxygen <code class="docutils literal notranslate"><span class="pre">.xsd</span></code> files contain levels of abstraction that
the <code class="docutils literal notranslate"><span class="pre">generateDS</span></code> project did not cope with at the time I used it. It is
possible that newer versions would handle it better but for the moment I’m
content updating the derived classes to handle the cases I see missing.</p>
</section>
</section>
<section id="finders">
<h2>Finders<a class="headerlink" href="#finders" title="永久链接至标题">¶</a></h2>
<p>The finder classes have a relatively small but important job of finding objects
in the hierarchy generated by the parsers. For example, when a user specifies a
particular class for the <a class="reference internal" href="directives.html#doxygenclass"><span class="std std-ref">doxygenclass directive</span></a>, we use
the finder classes to go and find the object corresponding to that class.</p>
<p>In fact, if you look closely, it is the finders that use the parser entry points
to parse the xml and then find the objects. The finders also use <code class="docutils literal notranslate"><span class="pre">Filter</span></code>
objects to actually figure out if they have found what they are looking for.</p>
<p>The finder is given a hierarchy of filter objects which are designed to match
at different levels of the XML hierarchy. Filters can also represent logical
conditions such as ‘and’ and ‘or’.</p>
<section id="more-details-please">
<h3>More Details, Please<a class="headerlink" href="#more-details-please" title="永久链接至标题">¶</a></h3>
<p>So initially, we create a finder to look at the root of the hierarchy: the
<strong>doxygenTypeSub</strong> node. That finder, handily called
<strong>DoxygenTypeSubItemFinder</strong> (you’ll notice a lot of that) looks through all the
child compound nodes of the <strong>doxygenTypeSub</strong> node and tries a compound-level
match against each of them and if something matches it creates a
<strong>CompoundTypeSubItemFinder</strong> to look further.</p>
<p>In turn, that checks each of its member child nodes with a member-level match
and if it finds one it creates a <strong>MemberTypeSubItemFinder</strong> (see the pattern?)
and that does another check. The interesting part is, if that is successful, the
<strong>CompoundTypeSubItemFinder</strong> finds the corresponding xml file that has more
information in it (remember <code class="docutils literal notranslate"><span class="pre">refid</span> <span class="pre">+</span> <span class="pre">.xml</span></code>?) and parses that and creates
another finder to start looking in there. This time it is a
<strong>DoxygenTypeSubItemFinder</strong> from the <code class="docutils literal notranslate"><span class="pre">breathe.finder.doxygen.compound</span></code>
module. And the search goes on until we find an object to return for rendering.</p>
<p>If the <strong>CompoundTypeSubItemFinder</strong> fails to find any deeper levels to match
against then it returns itself as it must be the target we’re interested in.</p>
<p>As stated, the job of the finder is to find a single node for the renderers to
starting rendering to reStructuredText. That is all the finder does.</p>
</section>
</section>
<section id="renderers">
<h2>Renderers<a class="headerlink" href="#renderers" title="永久链接至标题">¶</a></h2>
<p>Finally, the bit that really does something we care about. Rendering is the art
of turning whatever object we’ve found in the hierarchy into reStructuredText
nodes. This almost invariably means most of its children as well.</p>
<p>Much like with the finder classes, we start off creating a renderer for a
particular parser object and then it looks at its children and uses the renderer
factory to create appropriate renderers for those objects and tells them to
render and they look at their object’s children and create appropriate renderers
for those and so on and so forth.</p>
<p>The node we start at is determined by the finder and ultimately by the user. The
whole process is kicked off by the <code class="docutils literal notranslate"><span class="pre">Builder</span></code> class, though it doesn’t really
do much. The aim of the renderers is to return a list of reStructuredText nodes
which is passed back to Sphinx to render into whatever you’re final output
format is.</p>
<p>There are two complicated bits here. All the different renderers and all the
different reStructuredText nodes.</p>
<section id="different-renderers">
<h3>Different Renderers<a class="headerlink" href="#different-renderers" title="永久链接至标题">¶</a></h3>
<p>Just like with the parsers, there is one renderer per node type. In fact there
is one renderer class per parser class and they are named almost the same and
are designed to match up. The renderers look at the data on the instance
of the corresponding parser class that they have been given and grab the
interesting bits and return reStructuredText nodes.</p>
<p>For reference on what there is to render, you can look at the parser class
definitions or at the raw xml to see what attributes there are to render.
Sometimes if something isn’t appearing in the final output, it is because the
renderer isn’t returning an reStructuredText representation of it so the
rendering code needs to be updated, and sometimes it is because the parser
classes are not picking it up properly so both the parser and the renderer code
needs to be updated.</p>
<p>Given a little bit of time, you get used to chasing through the xml nodes,
the parser classes and the corresponding renderers to figure out where all the
information is ending up.</p>
</section>
<section id="restructuredtext-nodes">
<h3>reStructuredText Nodes<a class="headerlink" href="#restructuredtext-nodes" title="永久链接至标题">¶</a></h3>
<p>We use the reStructuredText API as provided by the fabulous docutils project
and extended by Sphinx itself. For the most part, they are fairly straight
forward and they are certainly well named.</p>
<p>Unfortunately there are a lot of nodes and only certain ways of combining them.
It is also not always clear what arguments their constructs take. Whilst I’m
sure it would be possible to figure it out with time and the appropriate source
code, the use of them is not something I’ve found very well documented and my
code largely operates on a basis of trial and error.</p>
<p>One day I’m sure I’ll be enlightened, until then expect fairly naive code.</p>
</section>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="contributing.html">Contributing to Breathe</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">目录</a>
        &#160;&#160;::&#160;&#160;
        <a href="credits.html">Credits</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; 版权所有 2009-2014, Michael Jones.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.0.
    </div>
  </body>
</html>